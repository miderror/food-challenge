## Техническая документация проекта "Dev-Mentor"

### **Используется:**

*   **Язык:** python 3.12.0
*   **Telegram-бот:** aiogram 3.21.0
*   **Backend и Админ-панель:** django 5.2.5
*   **База данных:** postgresql
*   **Очередь задач:** celery
*   **Брокер сообщений и кэш:** redis
*   **Среда выполнения кода:** docker
*   **Веб-сервер (production):** nginx + gunicorn

### **Схема взаимодействия компонентов:**

1.  **пользователь** отправляет код в **telegram-бот (aiogram)**.
2.  бот создает задачу на проверку кода и помещает ее в очередь **redis**.
3.  **celery worker** (отдельный процесс) забирает задачу из очереди.
4.  worker запускает **docker-контейнер** для выполнения кода.
5.  после выполнения, Worker анализирует результат:
    *   если есть ошибка, сверяется с реестром типовых ошибок в **postgresql**.
    *   если совпадений нет, отправляет ошибку на анализ в **ai api (groq)**.
6.  worker сохраняет результат проверки (код, вывод, ошибку, ответ ai) в **postgresql**.
7.  worker через **telegram-бот** отправляет отформатированный результат пользователю.
8.  **администратор** через **админ-панель (django admin)** управляет пользователями, контентом и просматривает аналитику, обращаясь к данным в **postgresql**.

### **Ключевые компоненты и их логика**

#### 1. telegram-бот (`/bot`)
*   **роль:** пользовательский интерфейс.
*   **реализация:** написан на фреймворке `aiogram`. Структура:
    *   **`handlers`**: обработка команд (`/start`), сообщений (прием кода), нажатий на кнопки.
    *   **`keyboards`**: формирование кнопок меню (главное меню, кнопки после проверки).
    *   **`middlewares`**: промежуточное ПО для авторизации. Каждый запрос от пользователя сначала проверяется на наличие доступа.
    *   **`states`**: управление состояниями (например, состояние ожидания кода).

#### 2. backend (`/backend`)
*   **роль:** бизнес-логика, управление данными, административный интерфейс.
*   **реализация:** django-проект, разделенный на логические приложения:
    *   **`users`**: модели `User` и `Whitelist`. Отвечает за хранение данных о пользователях, их статистике и управление доступом.
    *   **`checker`**: модели `Check` (лог проверки) и `CommonError` (реестр ошибок). Здесь же находится `runner.py` — модуль для взаимодействия с docker, и `tasks.py` — celery-задача для полной логики проверки кода.
    *   **`content`**: модели `FAQ` и `SiteSettings` для управления контентом бота.
    *   **`sender`**: модель `Broadcast` для создания и управления рассылками.

#### 3. изолированное выполнение кода (`backend/checker/runner.py`)
меры безопасности:
*   **Изоляция:** контейнер не имеет доступа к сети (`network_disabled=True`) и основной файловой системе.
*   **Ограничение ресурсов:** установлены лимиты на использование CPU (`cpu_shares`) и оперативной памяти (`mem_limit`).
*   **Таймаут:** выполнение кода принудительно прерывается, если оно длится дольше заданного времени (`EXEC_TIMEOUT_SECONDS`).
*   **Безопасность:** отключена возможность повышения привилегий в контейнере (`no-new-privileges`).
*   **Очистка:** контейнер и временные файлы полностью удаляются после выполнения.

### **Запуск проекта в prod-режиме**

**Шаг 1: подготовка сервера**
*   установить `docker` и `docker compose`.
*   клонировать репозиторий проекта на сервер.

**Шаг 2: конфигурация**
*   создать `.env` в корне проекта.
*   заполнить все необходимые переменные:
    *   `DJANGO_SECRET_KEY`: cекретный ключ.
    *   `ALLOWED_HOSTS`: ip/домен сервера.
    *   `POSTGRES_*`: параметры для подключения к бд.
    *   `REDIS_HOST`: `redis` (имя сервиса в docker compose).
    *   `BOT_TOKEN`: токен telegram-бота.
    *   `AI_API_KEY`: ключ для api (groq).
    *   `AI_MODEL_NAME`: используемая модель (`llama3-8b-8192`).
    *   `RUNNER_VOLUME_NAME`: Имя docker-volume для временных файлов

**Шаг 3: сборка и запуск**
в корне проекта выполнить команды из `Makefile` (или напрямую команды `docker compose`):

1.  **собрать образы:**
    ```bash
    make build-prod
    ```
2.  **запустить все сервисы в фоновом режиме:**
    ```bash
    make up-prod
    ```

**Шаг 4: инициализация**

1.  **применить миграции:**
    ```bash
    make migrate-prod
    ```
2.  **создать администратора:**
    ```bash
    make superuser-prod
    ```
3.  **собрать статику:**
    ```bash
    make static-prod
    ```

### **Масштабирование проекта**

#### 1. увеличение производительности проверки кода
если очередь задач на проверку кода растет, можно увеличить количество **celery-воркеров**.
*   **действие:** в файле `docker/docker-compose.prod.yaml` можно увеличить количество реплик сервиса `celery_worker`, а также можно увеличить параметр `--concurrency` в команде запуска воркера, чтобы один воркер обрабатывал больше задач параллельно (зависит от мощности CPU сервера).

#### 2. добавление новых языков программирования
система готова к расширению поддержки языков.
*   **действие:** в файле `backend/checker/runner.py` достаточно добавить новую запись в словарь `LANG_CONFIG`.
    ```python
    LANG_CONFIG = {
        "python": {
            "image": "python:3.12-slim",
            "command": lambda filename: f"python {filename}",
            "filename": "main.py"
        },
        "javascript": { // Пример добавления нового языка
            "image": "node:20-slim",
            "command": lambda filename: f"node {filename}",
            "filename": "index.js"
        },
    }
    ```
    после этого нужно будет доработать логику в боте, чтобы дать пользователю возможность выбирать язык.

#### 3. масштабирование веб-сервера и базы данных
*   **веб-сервер:** при высокой нагрузке на админ-панель можно увеличить количество gunicorn-воркеров в команде запуска сервиса `backend` или вынести его на отдельный сервер за балансировщиком нагрузки.
*   **база данных:** для postgresql можно настроить репликацию (read replicas), чтобы снизить нагрузку на основную базу данных от запросов на чтение (например, при генерации аналитики).
